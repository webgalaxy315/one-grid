{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://angular2-grid/helpers/NgGridHelpers.ts","ng://angular2-grid/components/NgGridPlaceholder.ts","ng://angular2-grid/directives/NgGrid.ts","ng://angular2-grid/directives/NgGridItem.ts","ng://angular2-grid/modules/NgGrid.module.ts"],"names":["__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","sortItemsByPositionHorizontal","a","b","col","row","sortItemsByPositionVertical","NgGridPlaceholder","_ngEl","_renderer","this","prototype","registerGrid","ngGrid","_ngGrid","ngOnInit","addClass","nativeElement","autoStyle","setStyle","setSize","newSize","_size","_recalculateDimensions","setGridPosition","newPosition","_position","_recalculatePosition","setCascadeMode","cascade","_cascadeMode","_setDimensions","w","h","_setPosition","x","y","colWidth","marginLeft","marginRight","screenMargin","rowHeight","marginTop","marginBottom","Component","args","selector","template","ElementRef","Renderer2","NgGrid","_differs","componentFactoryResolver","onDragStart","EventEmitter","onDrag","onDragStop","onResizeStart","onResize","onResizeStop","onItemChange","minCols","minRows","isDragging","isResizing","resizeEnable","dragEnable","minWidth","minHeight","resizeDirections","CONST_DEFAULT_RESIZE_DIRECTIONS","_items","Map","_draggingItem","_resizingItem","_resizeDirection","_itemsInGrid","Set","_maxCols","_maxRows","_visibleCols","_visibleRows","_setWidth","_setHeight","_posOffset","_adding","_placeholderRef","_fixToGrid","_autoResize","_destroyed","_maintainRatio","_preferNew","_zoomOnDrag","_limitToScreen","_centerToScreen","_curMaxRow","_curMaxCol","_dragReady","_resizeReady","_elementBasedDynamicRowHeight","_itemFixDirection","_collisionFixDirection","_allowOverlap","_lastZValue","_subscriptions","_enabledListener","_config","CONST_DEFAULT_CONFIG","_defineListeners","Object","defineProperty","v","setConfig","_differ","find","create","diff","ngOnDestroy","_disableListeners","generateItemUid","uid","replace","c","r","Math","random","toString","has","config","_this","maxColRowChanged","val","intVal","parseInt","setMargins","max","_cascadeGrid","console","warn","_enableListeners","_getFixDirectionFromCascade","newMaxCols","_getContainerColumns","_getScreenMargin","_aspectRatio","_updatePositionsAfterMaxChange","_calculateColWidth","_calculateRowHeight","maxWidth","maxHeight","ceil","_updateRatio","forEach","item","_removeFromGrid","recalculateSelf","_addToGrid","_updateSize","getItemPosition","itemId","get","getGridPosition","getItemSize","getSize","ngDoCheck","changes","_applyChanges","margins","enableDrag","disableDrag","enableResize","disableResize","addItem","ngItem","newPos","_fixGridPosition","set","triggerCascade","then","onCascadeEvent","_emitOnItemChange","removeItem","delete","updateItem","_cascadePromise","Promise","resolve","setTimeout","triggerResize","resizeEventHandler","e","newMaxColumns","mouseDownEventHandler","mousePos","_getMousePosition","_getItemFromPosition","resizeDirection","canResize","preventDefault","canDrag","itemPos","getPosition","left","top","mouseUpEventHandler","_dragStop","_resizeStop","_cleanDrag","_cleanResize","mouseMoveEventHandler","_resizeStart","_dragStart","_drag","_resize","onMouseMove","pos","dims","_hasGridCollision","_isWithinBounds","maxCols","getBoundingClientRect","width","floor","min_cols","maxRows","height","window","innerHeight","min_rows","forEachAddedItem","record","key","currentValue","forEachChangedItem","forEachRemovedItem","startMoving","_createPlaceholder","zIndex","emit","onResizeStartEvent","log","onDragStartEvent","_zoomOut","_resetZoom","getSelection","empty","removeAllRanges","selection","newL","newT","gridPos","_calculateGridPosition","_fixPosToBoundsX","_isWithinBoundsY","_fixPosToBoundsY","instance","indexOf","_fixGridCollisions","setPosition","onDragEvent","itemDims","getDimensions","endCorner","resizeTop","includes","resizeBottom","resizeLeft","newW","newH","newX","newY","calcSize","_calculateGridSize","itemSize","iGridPos","bottomRightCorner","targetPos","assign","_isWithinBoundsX","_fixSizeToBoundsX","_fixSizeToBoundsY","fixResize","setDimensions","onResizeEvent","stopMoving","onDragStopEvent","destroy","onResizeStopEvent","sizex","round","sizey","_getCollisions","returns","leftCol","rightCol","topRow","bottomRow","itemLeftCol","itemRightCol","itemTopRow","itemBottomRow","push","collisions","collisions_1","collisions_1_1","collision","newItemPos","Error","itemsInGrid","Array","from","sort","NgGridHelper.sortItemsByPositionVertical","lowestRowPerColumn","itemsInGrid_1","itemsInGrid_1_1","isFixed","lowestRowForItem","lowestRowForColumn","NgGridHelper.sortItemsByPositionHorizontal","lowestColumnPerRow","itemsInGrid_2","itemsInGrid_2_1","lowestColumnForItem","lowestOffsetColumn","maxRow","_getMaxRow","maxCol","_getMaxCol","fixLoop","itemsInPath","_getItemsInVerticalPath","nextRow","itemsInPath_1","e_4","itemsInPath_1_1","min","apply","map","_getItemsInHorizontalPath","nextCol","itemsInPath_2","e_5","itemsInPath_2_1","startColumn","startRow","allowExcessiveItems","_fixPosToBounds","_fixSizeToBounds","add","itemsRows","itemsCols","TouchEvent","touches","changedTouches","refPos","clientX","clientY","_getAbsoluteMousePosition","itemWidth","_getContainerRows","position","size","target","closest","containerRef","element","factory","resolveComponentFactory","componentRef","createComponent","placeholder","itemOutput","filter","getEventOutput","_documentMousemove$","fromEvent","document","_documentMouseup$","_mousedown$","_mousemove$","_mouseup$","_touchstart$","_touchmove$","_touchend$","_enableMouseListeners","_isTouchDevice","_enableTouchListeners","subs","unsubscribe","navigator","maxTouchPoints","touchstartSubs","subscribe","touchmoveSubs","touchendSubs","documentMousemoveSubs","documentMouseupSubs","mousedownSubs","mousemoveSubs","mouseupSubs","draggable","resizable","max_cols","max_rows","visible_cols","visible_rows","col_width","row_height","min_width","min_height","fix_to_grid","auto_style","auto_resize","maintain_ratio","prefer_new","zoom_on_drag","limit_to_screen","center_to_screen","resize_directions","element_based_row_height","fix_item_position_direction","fix_collision_position_direction","allow_overlap","Directive","inputs","host","(window:resize)","KeyValueDiffers","ComponentFactoryResolver","Output","NgGridItem","onDragAny","onResizeAny","onChangeStart","onChange","onChangeStop","onChangeAny","ngGridItemChange","isDraggable","isResizable","_currentPosition","_userConfig","_added","_minCols","_minRows","_resizeDirections","_zIndex","configObject","event","onConfigChangeEvent","_dragHandle","findHandle","handleSelector","startElement","targetElem","elementMatches","parentElement","err","_resizeHandle","resizeDirections_1","resizeDirections_1_1","direction","_borderSize","_c","_d","canResizeInDirection","cursor","getElement","getDragHandle","getResizeHandle","_elemWidth","_elemHeight","_elemLeft","_elemTop","_payload","payload","dragHandle","resizeHandle","borderSize","fixed","isNaN","isFinite","update","gridPosition","style","getComputedStyle","getPropertyValue","removeClass","matches","oMatchesSelector","msMatchesSelector","mozMatchesSelector","webkitMatchesSelector","ownerDocument","querySelectorAll","newWidth","newHeight","originalEvent","oe","changed","changeCheck","ViewContainerRef","NgGridModule","NgModule","declarations","entryComponents","exports"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { NgGridItem } from \"../directives/NgGridItem\";\n\nexport function generateUuid(): string {\n\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n\t\tlet r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n\t\treturn v.toString(16);\n\t});\n}\n\nexport function sortItemsByPositionHorizontal(a: NgGridItem, b: NgGridItem): number {\n\tif (a.col === b.col) { return a.row - b.row; }\n\treturn a.col - b.col;\n}\n\nexport function sortItemsByPositionVertical(a: NgGridItem, b: NgGridItem): number {\n\tif (a.row === b.row) { return a.col - b.col; }\n\treturn a.row - b.row;\n}\n","import { NgGrid } from '../directives/NgGrid';\nimport { NgGridItemPosition, NgGridItemSize } from '../interfaces/INgGrid';\nimport { Component, Directive, ElementRef, Renderer2, EventEmitter, Host, ViewEncapsulation, Type, ComponentRef, KeyValueDiffer, KeyValueDiffers, OnInit, OnDestroy, DoCheck, ViewContainerRef, Output } from '@angular/core';\n\n@Component({\n    selector: 'ng-grid-placeholder',\n    template: ''\n})\nexport class NgGridPlaceholder implements OnInit {\n    private _size: NgGridItemSize;\n    private _position: NgGridItemPosition;\n    private _ngGrid: NgGrid;\n    private _cascadeMode: string;\n\n    constructor(private _ngEl: ElementRef, private _renderer: Renderer2) { }\n\n    public registerGrid(ngGrid: NgGrid) {\n        this._ngGrid = ngGrid;\n    }\n\n    public ngOnInit(): void {\n        this._renderer.addClass(this._ngEl.nativeElement, 'grid-placeholder');\n        if (this._ngGrid.autoStyle) this._renderer.setStyle(this._ngEl.nativeElement, 'position', 'absolute');\n    }\n\n    public setSize(newSize: NgGridItemSize): void {\n        this._size = newSize;\n        this._recalculateDimensions();\n    }\n\n    public setGridPosition(newPosition: NgGridItemPosition): void {\n        this._position = newPosition;\n        this._recalculatePosition();\n    }\n\n    public setCascadeMode(cascade: string): void {\n        this._cascadeMode = cascade;\n        switch (cascade) {\n            case 'up':\n            case 'left':\n            default:\n                this._renderer.setStyle(this._ngEl.nativeElement, 'left', '0px');\n                this._renderer.setStyle(this._ngEl.nativeElement, 'top', '0px');\n                this._renderer.setStyle(this._ngEl.nativeElement, 'right', null);\n                this._renderer.setStyle(this._ngEl.nativeElement, 'bottom', null);\n                break;\n            case 'right':\n                this._renderer.setStyle(this._ngEl.nativeElement, 'right', '0px');\n                this._renderer.setStyle(this._ngEl.nativeElement, 'top', '0px');\n                this._renderer.setStyle(this._ngEl.nativeElement, 'left', null);\n                this._renderer.setStyle(this._ngEl.nativeElement, 'bottom', null);\n                break;\n            case 'down':\n                this._renderer.setStyle(this._ngEl.nativeElement, 'left', '0px');\n                this._renderer.setStyle(this._ngEl.nativeElement, 'bottom', '0px');\n                this._renderer.setStyle(this._ngEl.nativeElement, 'right', null);\n                this._renderer.setStyle(this._ngEl.nativeElement, 'top', null);\n                break;\n        }\n    }\n\n    // Private methods\n    private _setDimensions(w: number, h: number): void {\n        this._renderer.setStyle(this._ngEl.nativeElement, 'width', w + 'px');\n        this._renderer.setStyle(this._ngEl.nativeElement, 'height', h + 'px');\n    }\n\n    private _setPosition(x: number, y: number): void {\n        switch (this._cascadeMode) {\n            case 'up':\n            case 'left':\n            default:\n                this._renderer.setStyle(this._ngEl.nativeElement, 'transform', 'translate(' + x + 'px, ' + y + 'px)');\n                break;\n            case 'right':\n                this._renderer.setStyle(this._ngEl.nativeElement, 'transform', 'translate(' + -x + 'px, ' + y + 'px)');\n                break;\n            case 'down':\n                this._renderer.setStyle(this._ngEl.nativeElement, 'transform', 'translate(' + x + 'px, ' + -y + 'px)');\n                break;\n        }\n    }\n\n    private _recalculatePosition(): void {\n        const x: number = (this._ngGrid.colWidth + this._ngGrid.marginLeft + this._ngGrid.marginRight) * (this._position.col - 1) + this._ngGrid.marginLeft + this._ngGrid.screenMargin;\n        const y: number = (this._ngGrid.rowHeight + this._ngGrid.marginTop + this._ngGrid.marginBottom) * (this._position.row - 1) + this._ngGrid.marginTop;\n        this._setPosition(x, y);\n    }\n\n    private _recalculateDimensions(): void {\n        const w: number = (this._ngGrid.colWidth * this._size.x) + ((this._ngGrid.marginLeft + this._ngGrid.marginRight) * (this._size.x - 1));\n        const h: number = (this._ngGrid.rowHeight * this._size.y) + ((this._ngGrid.marginTop + this._ngGrid.marginBottom) * (this._size.y - 1));\n        this._setDimensions(w, h);\n    }\n}\n","import { Component, Directive, ElementRef, Renderer2, EventEmitter, ComponentFactoryResolver, Host, ViewEncapsulation, Type, ComponentRef, KeyValueDiffer, KeyValueDiffers, OnInit, OnDestroy, DoCheck, ViewContainerRef, Output } from '@angular/core';\nimport { NgGridConfig, NgGridItemEvent, NgGridItemPosition, NgGridItemSize, NgGridRawPosition, NgGridItemDimensions, NgConfigFixDirection } from '../interfaces/INgGrid';\nimport { NgGridItem } from './NgGridItem';\nimport * as NgGridHelper from '../helpers/NgGridHelpers';\nimport { NgGridPlaceholder } from '../components/NgGridPlaceholder';\nimport { Subscription, Observable, fromEvent } from 'rxjs';\n\n@Directive({\n    selector: '[ngGrid]',\n    inputs: ['config: ngGrid'],\n    host: {\n        '(window:resize)': 'resizeEventHandler($event)',\n    }\n})\nexport class NgGrid implements OnInit, DoCheck, OnDestroy {\n    public static CONST_DEFAULT_RESIZE_DIRECTIONS: string[] = [\n        'bottomright',\n        'bottomleft',\n        'topright',\n        'topleft',\n        'right',\n        'left',\n        'bottom',\n        'top',\n    ];\n\n    // Event Emitters\n    @Output() public onDragStart: EventEmitter<NgGridItem> = new EventEmitter<NgGridItem>();\n    @Output() public onDrag: EventEmitter<NgGridItem> = new EventEmitter<NgGridItem>();\n    @Output() public onDragStop: EventEmitter<NgGridItem> = new EventEmitter<NgGridItem>();\n    @Output() public onResizeStart: EventEmitter<NgGridItem> = new EventEmitter<NgGridItem>();\n    @Output() public onResize: EventEmitter<NgGridItem> = new EventEmitter<NgGridItem>();\n    @Output() public onResizeStop: EventEmitter<NgGridItem> = new EventEmitter<NgGridItem>();\n    @Output() public onItemChange: EventEmitter<Array<NgGridItemEvent>> = new EventEmitter<Array<NgGridItemEvent>>();\n\n    // Public variables\n    public colWidth: number = 250;\n    public rowHeight: number = 250;\n    public minCols: number = 1;\n    public minRows: number = 1;\n    public marginTop: number = 10;\n    public marginRight: number = 10;\n    public marginBottom: number = 10;\n    public marginLeft: number = 10;\n    public screenMargin: number = 0;\n    public isDragging: boolean = false;\n    public isResizing: boolean = false;\n    public autoStyle: boolean = true;\n    public resizeEnable: boolean = true;\n    public dragEnable: boolean = true;\n    public cascade: string = 'up';\n    public minWidth: number = 100;\n    public minHeight: number = 100;\n    public resizeDirections: string[] = NgGrid.CONST_DEFAULT_RESIZE_DIRECTIONS;\n\n    // Private variables\n    private _items: Map<string, NgGridItem> = new Map<string, NgGridItem>();\n    private _draggingItem: NgGridItem = null;\n    private _resizingItem: NgGridItem = null;\n    private _resizeDirection: string = null;\n    private _itemsInGrid: Set<string> = new Set<string>();\n    private _containerWidth: number;\n    private _containerHeight: number;\n    private _maxCols: number = 0;\n    private _maxRows: number = 0;\n    private _visibleCols: number = 0;\n    private _visibleRows: number = 0;\n    private _setWidth: number = 250;\n    private _setHeight: number = 250;\n    private _posOffset: NgGridRawPosition = null;\n    private _adding: boolean = false;\n    private _placeholderRef: ComponentRef<NgGridPlaceholder> = null;\n    private _fixToGrid: boolean = false;\n    private _autoResize: boolean = false;\n    private _differ: KeyValueDiffer<string, any>;\n    private _destroyed: boolean = false;\n    private _maintainRatio: boolean = false;\n    private _aspectRatio: number;\n    private _preferNew: boolean = false;\n    private _zoomOnDrag: boolean = false;\n    private _limitToScreen: boolean = false;\n    private _centerToScreen: boolean = false;\n    private _curMaxRow: number = 0;\n    private _curMaxCol: number = 0;\n    private _dragReady: boolean = false;\n    private _resizeReady: boolean = false;\n    private _elementBasedDynamicRowHeight: boolean = false;\n    private _itemFixDirection: NgConfigFixDirection = 'cascade';\n    private _collisionFixDirection: NgConfigFixDirection = 'cascade';\n    private _allowOverlap: boolean = false;\n    private _cascadePromise: Promise<void>;\n    private _lastZValue: number = 1;\n\n    // Events\n    private _documentMousemove$: Observable<MouseEvent>;\n    private _documentMouseup$: Observable<MouseEvent>;\n    private _mousedown$: Observable<MouseEvent>;\n    private _mousemove$: Observable<MouseEvent>;\n    private _mouseup$: Observable<MouseEvent>;\n    private _touchstart$: Observable<TouchEvent>;\n    private _touchmove$: Observable<TouchEvent>;\n    private _touchend$: Observable<TouchEvent>;\n    private _subscriptions: Subscription[] = [];\n\n    private _enabledListener: boolean = false;\n\n    // Default config\n    private static CONST_DEFAULT_CONFIG: NgGridConfig = {\n        margins: [10],\n        draggable: true,\n        resizable: true,\n        max_cols: 0,\n        max_rows: 0,\n        visible_cols: 0,\n        visible_rows: 0,\n        col_width: 250,\n        row_height: 250,\n        cascade: 'up',\n        min_width: 100,\n        min_height: 100,\n        fix_to_grid: false,\n        auto_style: true,\n        auto_resize: false,\n        maintain_ratio: false,\n        prefer_new: false,\n        zoom_on_drag: false,\n        limit_to_screen: false,\n        center_to_screen: false,\n        resize_directions: NgGrid.CONST_DEFAULT_RESIZE_DIRECTIONS,\n        element_based_row_height: false,\n        fix_item_position_direction: 'cascade',\n        fix_collision_position_direction: 'cascade',\n        allow_overlap: false,\n    };\n    private _config = NgGrid.CONST_DEFAULT_CONFIG;\n\n    // [ng-grid] attribute handler\n    set config(v: NgGridConfig) {\n        if (v == null || typeof v !== 'object') {\n            return;\n        }\n\n        this.setConfig(v);\n\n        if (this._differ == null && v != null) {\n            this._differ = this._differs.find(this._config).create();\n        }\n\n        this._differ.diff(this._config);\n    }\n\n    // Constructor\n    constructor(\n        private _differs: KeyValueDiffers,\n        private _ngEl: ElementRef,\n        private _renderer: Renderer2,\n        private componentFactoryResolver: ComponentFactoryResolver,\n    ) {\n        this._defineListeners();\n    }\n\n    // Public methods\n    public ngOnInit(): void {\n        this._renderer.addClass(this._ngEl.nativeElement, 'grid');\n        if (this.autoStyle) this._renderer.setStyle(this._ngEl.nativeElement, 'position', 'relative');\n        this.setConfig(this._config);\n    }\n\n    public ngOnDestroy(): void {\n        this._destroyed = true;\n        this._disableListeners();\n    }\n\n    public generateItemUid(): string {\n        const uid: string = NgGridHelper.generateUuid();\n\n        if (this._items.has(uid)) {\n            return this.generateItemUid();\n        }\n\n        return uid;\n    }\n\n    public setConfig(config: NgGridConfig): void {\n        this._config = config;\n\n        var maxColRowChanged = false;\n        for (var x in config) {\n            var val = config[x];\n            var intVal = !val ? 0 : parseInt(val);\n\n            switch (x) {\n                case 'margins':\n                    this.setMargins(val);\n                    break;\n                case 'col_width':\n                    this.colWidth = Math.max(intVal, 1);\n                    break;\n                case 'row_height':\n                    this.rowHeight = Math.max(intVal, 1);\n                    break;\n                case 'auto_style':\n                    this.autoStyle = val ? true : false;\n                    break;\n                case 'auto_resize':\n                    this._autoResize = val ? true : false;\n                    break;\n                case 'draggable':\n                    this.dragEnable = val ? true : false;\n                    break;\n                case 'resizable':\n                    this.resizeEnable = val ? true : false;\n                    break;\n                case 'max_rows':\n                    maxColRowChanged = maxColRowChanged || this._maxRows != intVal;\n                    this._maxRows = intVal < 0 ? 0 : intVal;\n                    break;\n                case 'max_cols':\n                    maxColRowChanged = maxColRowChanged || this._maxCols != intVal;\n                    this._maxCols = intVal < 0 ? 0 : intVal;\n                    break;\n                case 'visible_rows':\n                    this._visibleRows = Math.max(intVal, 0);\n                    break;\n                case 'visible_cols':\n                    this._visibleCols = Math.max(intVal, 0);\n                    break;\n                case 'min_rows':\n                    this.minRows = Math.max(intVal, 1);\n                    break;\n                case 'min_cols':\n                    this.minCols = Math.max(intVal, 1);\n                    break;\n                case 'min_height':\n                    this.minHeight = Math.max(intVal, 1);\n                    break;\n                case 'min_width':\n                    this.minWidth = Math.max(intVal, 1);\n                    break;\n                case 'zoom_on_drag':\n                    this._zoomOnDrag = val ? true : false;\n                    break;\n                case 'cascade':\n                    if (this.cascade != val) {\n                        this.cascade = val;\n                        this._cascadeGrid();\n                    }\n                    break;\n                case 'fix_to_grid':\n                    this._fixToGrid = val ? true : false;\n                    break;\n                case 'maintain_ratio':\n                    this._maintainRatio = val ? true : false;\n                    break;\n                case 'prefer_new':\n                    this._preferNew = val ? true : false;\n                    break;\n                case 'limit_to_screen':\n                    this._limitToScreen = !this._autoResize && !!val;\n                    break;\n                case 'center_to_screen':\n                    this._centerToScreen = val ? true : false;\n                    break;\n                case 'resize_directions':\n                    this.resizeDirections = val || ['bottomright', 'bottomleft', 'topright', 'topleft', 'right', 'left', 'bottom', 'top'];\n                    break;\n                case 'element_based_row_height':\n                    this._elementBasedDynamicRowHeight = !!val;\n                    break;\n                case 'fix_item_position_direction':\n                    this._itemFixDirection = val;\n                    break;\n                case 'fix_collision_position_direction':\n                    this._collisionFixDirection = val;\n                    break;\n                case 'allow_overlap':\n                    this._allowOverlap = !!val;\n                    break;\n            }\n        }\n\n        if (this._allowOverlap && this.cascade !== 'off' && this.cascade !== '') {\n            console.warn('Unable to overlap items when a cascade direction is set.');\n            this._allowOverlap = false;\n        }\n\n        if (this.dragEnable || this.resizeEnable) {\n            this._enableListeners();\n        } else {\n            this._disableListeners();\n        }\n\n        if (this._itemFixDirection === 'cascade') {\n            this._itemFixDirection = this._getFixDirectionFromCascade();\n        }\n\n        if (this._collisionFixDirection === 'cascade') {\n            this._collisionFixDirection = this._getFixDirectionFromCascade();\n        }\n\n        if (this._limitToScreen) {\n            const newMaxCols = this._getContainerColumns();\n\n            if (this._maxCols != newMaxCols) {\n                this._maxCols = newMaxCols;\n                maxColRowChanged = true;\n            }\n        }\n\n        if (this._limitToScreen && this._centerToScreen) {\n            this.screenMargin = this._getScreenMargin();\n        } else {\n            this.screenMargin = 0;\n        }\n\n        if (this._maintainRatio) {\n            if (this.colWidth && this.rowHeight) {\n                this._aspectRatio = this.colWidth / this.rowHeight;\n            } else {\n                this._maintainRatio = false;\n            }\n        }\n\n        if (maxColRowChanged) {\n            if (this._maxCols > 0 && this._maxRows > 0) {    //    Can't have both, prioritise on cascade\n                switch (this.cascade) {\n                    case 'left':\n                    case 'right':\n                        this._maxCols = 0;\n                        break;\n                    case 'up':\n                    case 'down':\n                    default:\n                        this._maxRows = 0;\n                        break;\n                }\n            }\n\n            this._updatePositionsAfterMaxChange();\n        }\n\n        this._calculateColWidth();\n        this._calculateRowHeight();\n\n        var maxWidth = this._maxCols * this.colWidth;\n        var maxHeight = this._maxRows * this.rowHeight;\n\n        if (maxWidth > 0 && this.minWidth > maxWidth) this.minWidth = 0.75 * this.colWidth;\n        if (maxHeight > 0 && this.minHeight > maxHeight) this.minHeight = 0.75 * this.rowHeight;\n\n        if (this.minWidth > this.colWidth) this.minCols = Math.max(this.minCols, Math.ceil(this.minWidth / this.colWidth));\n        if (this.minHeight > this.rowHeight) this.minRows = Math.max(this.minRows, Math.ceil(this.minHeight / this.rowHeight));\n\n        if (this._maxCols > 0 && this.minCols > this._maxCols) this.minCols = 1;\n        if (this._maxRows > 0 && this.minRows > this._maxRows) this.minRows = 1;\n\n        this._updateRatio();\n\n        this._items.forEach((item: NgGridItem) => {\n            this._removeFromGrid(item);\n            item.setCascadeMode(this.cascade);\n        });\n\n        this._items.forEach((item: NgGridItem) => {\n            item.recalculateSelf();\n            this._addToGrid(item);\n        });\n\n        this._cascadeGrid();\n        this._updateSize();\n    }\n\n    public getItemPosition(itemId: string): NgGridItemPosition {\n        return this._items.has(itemId) ? this._items.get(itemId).getGridPosition() : null;\n    }\n\n    public getItemSize(itemId: string): NgGridItemSize {\n        return this._items.has(itemId) ? this._items.get(itemId).getSize() : null;\n    }\n\n    public ngDoCheck(): boolean {\n        if (this._differ != null) {\n            var changes = this._differ.diff(this._config);\n\n            if (changes != null) {\n                this._applyChanges(changes);\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public setMargins(margins: Array<string>): void {\n        this.marginTop = Math.max(parseInt(margins[0]), 0);\n        this.marginRight = margins.length >= 2 ? Math.max(parseInt(margins[1]), 0) : this.marginTop;\n        this.marginBottom = margins.length >= 3 ? Math.max(parseInt(margins[2]), 0) : this.marginTop;\n        this.marginLeft = margins.length >= 4 ? Math.max(parseInt(margins[3]), 0) : this.marginRight;\n    }\n\n    public enableDrag(): void {\n        this.dragEnable = true;\n    }\n\n    public disableDrag(): void {\n        this.dragEnable = false;\n    }\n\n    public enableResize(): void {\n        this.resizeEnable = true;\n    }\n\n    public disableResize(): void {\n        this.resizeEnable = false;\n    }\n\n    public addItem(ngItem: NgGridItem): void {\n        ngItem.setCascadeMode(this.cascade);\n\n        if (!this._preferNew) {\n            var newPos = this._fixGridPosition(ngItem.getGridPosition(), ngItem.getSize());\n            ngItem.setGridPosition(newPos);\n        }\n\n        if (ngItem.uid === null || this._items.has(ngItem.uid)) {\n            ngItem.uid = this.generateItemUid();\n        }\n\n        this._items.set(ngItem.uid, ngItem);\n        this._addToGrid(ngItem);\n\n        this._updateSize();\n\n        this.triggerCascade().then(() => {\n            ngItem.recalculateSelf();\n            ngItem.onCascadeEvent();\n\n            this._emitOnItemChange();\n        });\n\n    }\n\n    public removeItem(ngItem: NgGridItem): void {\n        this._removeFromGrid(ngItem);\n\n        this._items.delete(ngItem.uid);\n\n        if (this._destroyed) return;\n\n        this.triggerCascade().then(() => {\n            this._updateSize();\n            this._items.forEach((item: NgGridItem) => item.recalculateSelf());\n            this._emitOnItemChange();\n        });\n    }\n\n    public updateItem(ngItem: NgGridItem): void {\n        this._removeFromGrid(ngItem);\n        this._addToGrid(ngItem);\n\n        this.triggerCascade().then(() => {\n            this._updateSize();\n            ngItem.onCascadeEvent();\n        });\n    }\n\n    public triggerCascade(): Promise<void> {\n        if (!this._cascadePromise) {\n            this._cascadePromise = new Promise<void>((resolve: () => void) => {\n                setTimeout(() => {\n                    this._cascadePromise = null;\n                    this._cascadeGrid(null, null);\n                    resolve();\n                }, 0);\n            });\n        }\n\n        return this._cascadePromise;\n    }\n\n    public triggerResize(): void {\n        this.resizeEventHandler(null);\n    }\n\n    public resizeEventHandler(e: any): void {\n        // this._calculateColWidth();\n        // this._calculateRowHeight();\n\n        // this._updateRatio();\n\n        if (this._limitToScreen) {\n            const newMaxColumns = this._getContainerColumns();\n            if (this._maxCols !== newMaxColumns) {\n                this._maxCols = newMaxColumns;\n                // this._updatePositionsAfterMaxChange();\n                // this._cascadeGrid();\n            }\n\n            if (this._centerToScreen) {\n                this.screenMargin = this._getScreenMargin();\n\n                this._items.forEach((item: NgGridItem) => {\n                    item.recalculateSelf();\n                });\n            }\n        } else if (this._autoResize) {\n            this._items.forEach((item: NgGridItem) => {\n                item.recalculateSelf();\n            });\n        }\n\n        // this._updateSize();\n    }\n\n    public mouseDownEventHandler(e: MouseEvent | TouchEvent): void {\n        var mousePos = this._getMousePosition(e);\n        var item = this._getItemFromPosition(mousePos, e);\n\n        if (item == null) return;\n\n        const resizeDirection: string = item.canResize(e);\n\n        if (this.resizeEnable && resizeDirection) {\n            this._resizeReady = true;\n            this._resizingItem = item;\n            this._resizeDirection = resizeDirection;\n\n            e.preventDefault();\n        } else if (this.dragEnable && item.canDrag(e)) {\n            this._dragReady = true;\n            this._draggingItem = item;\n\n            const itemPos = item.getPosition();\n            this._posOffset = { 'left': (mousePos.left - itemPos.left), 'top': (mousePos.top - itemPos.top) }\n\n            e.preventDefault();\n        }\n    }\n\n    public mouseUpEventHandler(e: MouseEvent | TouchEvent): void {\n        if (this.isDragging) {\n            this._dragStop(e);\n        } else if (this.isResizing) {\n            this._resizeStop(e);\n        } else if (this._dragReady || this._resizeReady) {\n            this._cleanDrag();\n            this._cleanResize();\n        }\n    }\n\n    public mouseMoveEventHandler(e: MouseEvent | TouchEvent): void {\n        if (this._resizeReady) {\n            this._resizeStart(e);\n            e.preventDefault();\n            return;\n        } else if (this._dragReady) {\n            this._dragStart(e);\n            e.preventDefault();\n            return;\n        }\n\n        if (this.isDragging) {\n            this._drag(e);\n        } else if (this.isResizing) {\n            this._resize(e);\n        } else {\n            var mousePos = this._getMousePosition(e);\n            var item = this._getItemFromPosition(mousePos);\n\n            if (item) {\n                item.onMouseMove(e);\n            }\n        }\n    }\n\n    //    Private methods\n    private _getFixDirectionFromCascade(): NgConfigFixDirection {\n        switch (this.cascade) {\n            case 'up':\n            case 'down':\n            default:\n                return 'vertical';\n            case 'left':\n            case 'right':\n                return 'horizontal';\n        }\n    }\n    private _updatePositionsAfterMaxChange(): void {\n        this._items.forEach((item: NgGridItem) => {\n            var pos = item.getGridPosition();\n            var dims = item.getSize();\n\n            if (!this._hasGridCollision(pos, dims) && this._isWithinBounds(pos, dims) && dims.x <= this._maxCols && dims.y <= this._maxRows) {\n                return;\n            }\n\n            this._removeFromGrid(item);\n\n            if (this._maxCols > 0 && dims.x > this._maxCols) {\n                dims.x = this._maxCols;\n                item.setSize(dims);\n            } else if (this._maxRows > 0 && dims.y > this._maxRows) {\n                dims.y = this._maxRows;\n                item.setSize(dims);\n            }\n\n            if (this._hasGridCollision(pos, dims) || !this._isWithinBounds(pos, dims, true)) {\n                var newPosition = this._fixGridPosition(pos, dims);\n                item.setGridPosition(newPosition);\n            }\n\n            this._addToGrid(item);\n        });\n    }\n\n    private _calculateColWidth(): void {\n        if (this._autoResize) {\n            if (this._maxCols > 0 || this._visibleCols > 0) {\n                var maxCols = this._maxCols > 0 ? this._maxCols : this._visibleCols;\n                var maxWidth: number = this._ngEl.nativeElement.getBoundingClientRect().width;\n\n                var colWidth: number = Math.floor(maxWidth / maxCols);\n                colWidth -= (this.marginLeft + this.marginRight);\n                if (colWidth > 0) this.colWidth = colWidth;\n\n            }\n        }\n\n        if (this.colWidth < this.minWidth || this.minCols > this._config.min_cols) {\n            this.minCols = Math.max(this._config.min_cols, Math.ceil(this.minWidth / this.colWidth));\n        }\n    }\n\n    private _calculateRowHeight(): void {\n        if (this._autoResize) {\n            if (this._maxRows > 0 || this._visibleRows > 0) {\n                var maxRows = this._maxRows > 0 ? this._maxRows : this._visibleRows;\n                let maxHeight: number;\n\n                if (this._elementBasedDynamicRowHeight) {\n                    maxHeight = this._ngEl.nativeElement.getBoundingClientRect().height;\n                } else {\n                    maxHeight = window.innerHeight - this.marginTop - this.marginBottom;\n                }\n\n                var rowHeight: number = Math.max(Math.floor(maxHeight / maxRows), this.minHeight);\n                rowHeight -= (this.marginTop + this.marginBottom);\n                if (rowHeight > 0) this.rowHeight = rowHeight;\n\n            }\n        }\n\n        if (this.rowHeight < this.minHeight || this.minRows > this._config.min_rows) {\n            this.minRows = Math.max(this._config.min_rows, Math.ceil(this.minHeight / this.rowHeight));\n        }\n    }\n\n    private _updateRatio(): void {\n        if (!this._autoResize || !this._maintainRatio) return;\n\n        if (this._maxCols > 0 && this._visibleRows <= 0) {\n            this.rowHeight = this.colWidth / this._aspectRatio;\n        } else if (this._maxRows > 0 && this._visibleCols <= 0) {\n            this.colWidth = this._aspectRatio * this.rowHeight;\n        } else if (this._maxCols == 0 && this._maxRows == 0) {\n            if (this._visibleCols > 0) {\n                this.rowHeight = this.colWidth / this._aspectRatio;\n            } else if (this._visibleRows > 0) {\n                this.colWidth = this._aspectRatio * this.rowHeight;\n            }\n        }\n    }\n\n    private _applyChanges(changes: any): void {\n        changes.forEachAddedItem((record: any) => { this._config[record.key] = record.currentValue; });\n        changes.forEachChangedItem((record: any) => { this._config[record.key] = record.currentValue; });\n        changes.forEachRemovedItem((record: any) => { delete this._config[record.key]; });\n\n        this.setConfig(this._config);\n    }\n\n    private _resizeStart(e: any): void {\n        if (!this.resizeEnable || !this._resizingItem) return;\n\n        //    Setup\n        this._resizingItem.startMoving();\n        this._removeFromGrid(this._resizingItem);\n        this._createPlaceholder(this._resizingItem);\n\n        if (this._allowOverlap) {\n            this._resizingItem.zIndex = this._lastZValue++;\n        }\n\n        //    Status Flags\n        this.isResizing = true;\n        this._resizeReady = false;\n\n        //    Events\n        this.onResizeStart.emit(this._resizingItem);\n        this._resizingItem.onResizeStartEvent();\n    }\n\n    private _dragStart(e: any): void {\n        if (!this.dragEnable || !this._draggingItem) return;\n\n        //    Start dragging\n        console.log(this._draggingItem);\n        this._draggingItem.startMoving();\n        this._removeFromGrid(this._draggingItem);\n        this._createPlaceholder(this._draggingItem);\n\n        if (this._allowOverlap) {\n            this._draggingItem.zIndex = this._lastZValue++;\n        }\n\n        //    Status Flags\n        this.isDragging = true;\n        this._dragReady = false;\n\n        //    Events\n        this.onDragStart.emit(this._draggingItem);\n        this._draggingItem.onDragStartEvent();\n\n        //    Zoom\n        if (this._zoomOnDrag) {\n            this._zoomOut();\n        }\n    }\n\n    private _zoomOut(): void {\n        this._renderer.setStyle(this._ngEl.nativeElement, 'transform', 'scale(0.5, 0.5)');\n    }\n\n    private _resetZoom(): void {\n        this._renderer.setStyle(this._ngEl.nativeElement, 'transform', '');\n    }\n\n    private _drag(e: any): void {\n        if (!this.isDragging) return;\n\n        if (window.getSelection) {\n            if (window.getSelection().empty) {\n                window.getSelection().empty();\n            } else if (window.getSelection().removeAllRanges) {\n                window.getSelection().removeAllRanges();\n            }\n        } else if ((<any>document).selection) {\n            (<any>document).selection.empty();\n        }\n\n        var mousePos = this._getMousePosition(e);\n        var newL = (mousePos.left - this._posOffset.left);\n        var newT = (mousePos.top - this._posOffset.top);\n\n        var itemPos = this._draggingItem.getGridPosition();\n        var gridPos = this._calculateGridPosition(newL, newT);\n        var dims = this._draggingItem.getSize();\n\n        gridPos = this._fixPosToBoundsX(gridPos, dims);\n\n        if (!this._isWithinBoundsY(gridPos, dims)) {\n            gridPos = this._fixPosToBoundsY(gridPos, dims);\n        }\n\n        if (gridPos.col != itemPos.col || gridPos.row != itemPos.row) {\n            this._draggingItem.setGridPosition(gridPos, this._fixToGrid);\n            this._placeholderRef.instance.setGridPosition(gridPos);\n\n            if (['up', 'down', 'left', 'right'].indexOf(this.cascade) >= 0) {\n                this._fixGridCollisions(gridPos, dims);\n                this._cascadeGrid(gridPos, dims);\n            }\n        }\n\n        if (!this._fixToGrid) {\n            this._draggingItem.setPosition(newL, newT);\n        }\n\n        this.onDrag.emit(this._draggingItem);\n        this._draggingItem.onDragEvent();\n    }\n\n    private _resize(e: any): void {\n        if (!this.isResizing) { return; }\n\n        if (window.getSelection) {\n            if (window.getSelection().empty) {\n                window.getSelection().empty();\n            } else if (window.getSelection().removeAllRanges) {\n                window.getSelection().removeAllRanges();\n            }\n        } else if ((<any>document).selection) {\n            (<any>document).selection.empty();\n        }\n\n        const mousePos = this._getMousePosition(e);\n        const itemPos = this._resizingItem.getPosition();\n        const itemDims = this._resizingItem.getDimensions();\n        const endCorner = {\n            left: itemPos.left + itemDims.width,\n            top: itemPos.top + itemDims.height,\n        }\n\n        const resizeTop = this._resizeDirection.includes('top');\n        const resizeBottom = this._resizeDirection.includes('bottom');\n        const resizeLeft = this._resizeDirection.includes('left')\n        const resizeRight = this._resizeDirection.includes('right');\n\n        // Calculate new width and height based upon resize direction\n        let newW = resizeRight\n            ? (mousePos.left - itemPos.left + 1)\n            : resizeLeft\n                ? (endCorner.left - mousePos.left + 1)\n                : itemDims.width;\n        let newH = resizeBottom\n            ? (mousePos.top - itemPos.top + 1)\n            : resizeTop\n                ? (endCorner.top - mousePos.top + 1)\n                : itemDims.height;\n\n        if (newW < this.minWidth)\n            newW = this.minWidth;\n        if (newH < this.minHeight)\n            newH = this.minHeight;\n        if (newW < this._resizingItem.minWidth)\n            newW = this._resizingItem.minWidth;\n        if (newH < this._resizingItem.minHeight)\n            newH = this._resizingItem.minHeight;\n\n        let newX = itemPos.left;\n        let newY = itemPos.top;\n\n        if (resizeLeft)\n            newX = endCorner.left - newW;\n        if (resizeTop)\n            newY = endCorner.top - newH;\n\n        let calcSize = this._calculateGridSize(newW, newH);\n        const itemSize = this._resizingItem.getSize();\n        const iGridPos = this._resizingItem.getGridPosition();\n        const bottomRightCorner = {\n            col: iGridPos.col + itemSize.x,\n            row: iGridPos.row + itemSize.y,\n        };\n        const targetPos: NgGridItemPosition = Object.assign({}, iGridPos);\n\n        if (this._resizeDirection.includes('top'))\n            targetPos.row = bottomRightCorner.row - calcSize.y;\n        if (this._resizeDirection.includes('left'))\n            targetPos.col = bottomRightCorner.col - calcSize.x;\n\n        if (!this._isWithinBoundsX(targetPos, calcSize))\n            calcSize = this._fixSizeToBoundsX(targetPos, calcSize);\n\n        if (!this._isWithinBoundsY(targetPos, calcSize))\n            calcSize = this._fixSizeToBoundsY(targetPos, calcSize);\n\n        calcSize = this._resizingItem.fixResize(calcSize);\n\n        if (calcSize.x != itemSize.x || calcSize.y != itemSize.y) {\n            this._resizingItem.setGridPosition(targetPos, this._fixToGrid);\n            this._placeholderRef.instance.setGridPosition(targetPos);\n            this._resizingItem.setSize(calcSize, this._fixToGrid);\n            this._placeholderRef.instance.setSize(calcSize);\n\n            if (['up', 'down', 'left', 'right'].indexOf(this.cascade) >= 0) {\n                this._fixGridCollisions(targetPos, calcSize);\n                this._cascadeGrid(targetPos, calcSize);\n            }\n        }\n\n        if (!this._fixToGrid) {\n            this._resizingItem.setDimensions(newW, newH);\n            this._resizingItem.setPosition(newX, newY);\n        }\n\n        this.onResize.emit(this._resizingItem);\n        this._resizingItem.onResizeEvent();\n    }\n\n    private _dragStop(e: any): void {\n        if (!this.isDragging) return;\n\n        this.isDragging = false;\n\n        var itemPos = this._draggingItem.getGridPosition();\n\n        this._draggingItem.setGridPosition(itemPos);\n        this._addToGrid(this._draggingItem);\n\n        this._cascadeGrid();\n        this._updateSize();\n\n        this._draggingItem.stopMoving();\n        this._draggingItem.onDragStopEvent();\n        this.onDragStop.emit(this._draggingItem);\n\n        this._cleanDrag();\n        this._placeholderRef.destroy();\n\n        this._emitOnItemChange();\n\n        if (this._zoomOnDrag) {\n            this._resetZoom();\n        }\n    }\n\n    private _resizeStop(e: any): void {\n        if (!this.isResizing) return;\n\n        this.isResizing = false;\n\n        const itemDims = this._resizingItem.getSize();\n        this._resizingItem.setSize(itemDims);\n\n        const itemPos = this._resizingItem.getGridPosition();\n        this._resizingItem.setGridPosition(itemPos);\n\n        this._addToGrid(this._resizingItem);\n\n        this._cascadeGrid();\n        this._updateSize();\n\n        this._resizingItem.stopMoving();\n        this._resizingItem.onResizeStopEvent();\n        this.onResizeStop.emit(this._resizingItem);\n\n        this._cleanResize();\n        this._placeholderRef.destroy();\n\n        this._emitOnItemChange();\n    }\n\n    private _cleanDrag(): void {\n        this._draggingItem = null;\n        this._posOffset = null;\n        this.isDragging = false;\n        this._dragReady = false;\n    }\n\n    private _cleanResize(): void {\n        this._resizingItem = null;\n        this._resizeDirection = null;\n        this.isResizing = false;\n        this._resizeReady = false;\n    }\n\n    private _calculateGridSize(width: number, height: number): NgGridItemSize {\n        width += this.marginLeft + this.marginRight;\n        height += this.marginTop + this.marginBottom;\n\n        var sizex = Math.max(this.minCols, Math.round(width / (this.colWidth + this.marginLeft + this.marginRight)));\n        var sizey = Math.max(this.minRows, Math.round(height / (this.rowHeight + this.marginTop + this.marginBottom)));\n\n        if (!this._isWithinBoundsX({ col: 1, row: 1 }, { x: sizex, y: sizey })) sizex = this._maxCols;\n        if (!this._isWithinBoundsY({ col: 1, row: 1 }, { x: sizex, y: sizey })) sizey = this._maxRows;\n\n        return { 'x': sizex, 'y': sizey };\n    }\n\n    private _calculateGridPosition(left: number, top: number): NgGridItemPosition {\n        var col = Math.max(1, Math.round(left / (this.colWidth + this.marginLeft + this.marginRight)) + 1);\n        var row = Math.max(1, Math.round(top / (this.rowHeight + this.marginTop + this.marginBottom)) + 1);\n\n        if (!this._isWithinBoundsX({ col: col, row: row }, { x: 1, y: 1 })) col = this._maxCols;\n        if (!this._isWithinBoundsY({ col: col, row: row }, { x: 1, y: 1 })) row = this._maxRows;\n\n        return { 'col': col, 'row': row };\n    }\n\n    private _hasGridCollision(pos: NgGridItemPosition, dims: NgGridItemSize): boolean {\n        return false;\n    }\n\n    private _getCollisions(pos: NgGridItemPosition, dims: NgGridItemSize): Array<NgGridItem> {\n        if (this._allowOverlap) return [];\n\n        const returns: Array<NgGridItem> = [];\n\n        if (!pos.col) { pos.col = 1; }\n        if (!pos.row) { pos.row = 1; }\n\n        const leftCol = pos.col;\n        const rightCol = pos.col + dims.x;\n        const topRow = pos.row;\n        const bottomRow = pos.row + dims.y;\n\n        this._itemsInGrid.forEach((itemId: string) => {\n            const item: NgGridItem = this._items.get(itemId);\n\n            if (!item) {\n                this._itemsInGrid.delete(itemId);\n                return;\n            }\n\n            const itemLeftCol = item.col;\n            const itemRightCol = item.col + item.sizex;\n            const itemTopRow = item.row;\n            const itemBottomRow = item.row + item.sizey;\n\n            const withinColumns = leftCol < itemRightCol && itemLeftCol < rightCol;\n            const withinRows = topRow < itemBottomRow && itemTopRow < bottomRow;\n\n            if (withinColumns && withinRows) {\n                returns.push(item);\n            }\n        });\n\n        return returns;\n    }\n\n    private _fixGridCollisions(pos: NgGridItemPosition, dims: NgGridItemSize): void {\n        const collisions: Array<NgGridItem> = this._getCollisions(pos, dims);\n        if (collisions.length === 0) { return; }\n\n        for (let collision of collisions) {\n            this._removeFromGrid(collision);\n\n            const itemDims: NgGridItemSize = collision.getSize();\n            const itemPos: NgGridItemPosition = collision.getGridPosition();\n            let newItemPos: NgGridItemPosition = { col: itemPos.col, row: itemPos.row };\n\n            if (this._collisionFixDirection === 'vertical') {\n                newItemPos.row = pos.row + dims.y;\n\n                if (!this._isWithinBoundsY(newItemPos, itemDims)) {\n                    newItemPos.col = pos.col + dims.x;\n                    newItemPos.row = 1;\n                }\n            } else if (this._collisionFixDirection === 'horizontal') {\n                newItemPos.col = pos.col + dims.x;\n\n                if (!this._isWithinBoundsX(newItemPos, itemDims)) {\n                    newItemPos.col = 1;\n                    newItemPos.row = pos.row + dims.y;\n                }\n            }\n\n            collision.setGridPosition(newItemPos);\n\n            this._fixGridCollisions(newItemPos, itemDims);\n            this._addToGrid(collision);\n            collision.onCascadeEvent();\n        }\n\n        this._fixGridCollisions(pos, dims);\n    }\n\n    private _cascadeGrid(pos?: NgGridItemPosition, dims?: NgGridItemSize): void {\n        if (this._destroyed) return;\n        if (this._allowOverlap) return;\n        if (!pos !== !dims) throw new Error('Cannot cascade with only position and not dimensions');\n\n        if (this.isDragging && this._draggingItem && !pos && !dims) {\n            pos = this._draggingItem.getGridPosition();\n            dims = this._draggingItem.getSize();\n        } else if (this.isResizing && this._resizingItem && !pos && !dims) {\n            pos = this._resizingItem.getGridPosition();\n            dims = this._resizingItem.getSize();\n        }\n\n        let itemsInGrid: NgGridItem[] = Array.from(this._itemsInGrid, (itemId: string) => this._items.get(itemId));\n\n        switch (this.cascade) {\n            case 'up':\n            case 'down':\n                itemsInGrid = itemsInGrid.sort(NgGridHelper.sortItemsByPositionVertical);\n                const lowestRowPerColumn: Map<number, number> = new Map<number, number>();\n\n                for (let item of itemsInGrid) {\n                    if (item.isFixed) continue;\n\n                    const itemDims: NgGridItemSize = item.getSize();\n                    const itemPos: NgGridItemPosition = item.getGridPosition();\n\n                    let lowestRowForItem: number = lowestRowPerColumn.get(itemPos.col) || 1;\n\n                    for (let i: number = 1; i < itemDims.x; i++) {\n                        const lowestRowForColumn = lowestRowPerColumn.get(itemPos.col + i) || 1;\n                        lowestRowForItem = Math.max(lowestRowForColumn, lowestRowForItem);\n                    }\n\n                    const leftCol = itemPos.col;\n                    const rightCol = itemPos.col + itemDims.x;\n\n                    if (pos && dims) {\n                        const withinColumns = rightCol > pos.col && leftCol < (pos.col + dims.x);\n\n                        if (withinColumns) {          // If our element is in one of the item's columns\n                            const roomAboveItem = itemDims.y <= (pos.row - lowestRowForItem);\n\n                            if (!roomAboveItem) {                                                  // Item can't fit above our element\n                                lowestRowForItem = Math.max(lowestRowForItem, pos.row + dims.y);   // Set the lowest row to be below it\n                            }\n                        }\n                    }\n\n                    const newPos: NgGridItemPosition = { col: itemPos.col, row: lowestRowForItem };\n\n                    //    What if it's not within bounds Y?\n                    if (lowestRowForItem != itemPos.row && this._isWithinBoundsY(newPos, itemDims)) { // If the item is not already on this row move it up\n                        this._removeFromGrid(item);\n\n                        item.setGridPosition(newPos);\n\n                        item.onCascadeEvent();\n                        this._addToGrid(item);\n                    }\n\n                    for (let i: number = 0; i < itemDims.x; i++) {\n                        lowestRowPerColumn.set(itemPos.col + i, lowestRowForItem + itemDims.y); // Update the lowest row to be below the item\n                    }\n                }\n                break;\n            case 'left':\n            case 'right':\n                itemsInGrid = itemsInGrid.sort(NgGridHelper.sortItemsByPositionHorizontal);\n                const lowestColumnPerRow: Map<number, number> = new Map<number, number>();\n\n                for (let item of itemsInGrid) {\n                    const itemDims: NgGridItemSize = item.getSize();\n                    const itemPos: NgGridItemPosition = item.getGridPosition();\n\n                    let lowestColumnForItem: number = lowestColumnPerRow.get(itemPos.row) || 1;\n\n                    for (let i: number = 1; i < itemDims.y; i++) {\n                        let lowestOffsetColumn: number = lowestColumnPerRow.get(itemPos.row + i) || 1;\n                        lowestColumnForItem = Math.max(lowestOffsetColumn, lowestColumnForItem);\n                    }\n\n                    const topRow = itemPos.row;\n                    const bottomRow = itemPos.row + itemDims.y;\n\n                    if (pos && dims) {\n                        const withinRows = bottomRow > pos.col && topRow < (pos.col + dims.x);\n\n                        if (withinRows) {          // If our element is in one of the item's rows\n                            const roomNextToItem = itemDims.x <= (pos.col - lowestColumnForItem);\n\n                            if (!roomNextToItem) {                                                      // Item can't fit next to our element\n                                lowestColumnForItem = Math.max(lowestColumnForItem, pos.col + dims.x);  // Set the lowest col to be the other side of it\n                            }\n                        }\n                    }\n\n                    const newPos: NgGridItemPosition = { col: lowestColumnForItem, row: itemPos.row };\n\n                    if (lowestColumnForItem != itemPos.col && this._isWithinBoundsX(newPos, itemDims)) { // If the item is not already on this col move it up\n                        this._removeFromGrid(item);\n\n                        item.setGridPosition(newPos);\n\n                        item.onCascadeEvent();\n                        this._addToGrid(item);\n                    }\n\n                    for (let i: number = 0; i < itemDims.y; i++) {\n                        lowestColumnPerRow.set(itemPos.row + i, lowestColumnForItem + itemDims.x); // Update the lowest col to be below the item\n                    }\n                }\n                break;\n            default:\n                break;\n        }\n    }\n\n    private _fixGridPosition(pos: NgGridItemPosition, dims: NgGridItemSize): NgGridItemPosition {\n        if (!this._hasGridCollision(pos, dims)) return pos;\n\n        const maxRow = this._maxRows === 0 ? this._getMaxRow() : this._maxRows;\n        const maxCol = this._maxCols === 0 ? this._getMaxCol() : this._maxCols;\n        const newPos = {\n            col: pos.col,\n            row: pos.row,\n        };\n\n        if (this._itemFixDirection === 'vertical') {\n            fixLoop:\n            for (; newPos.col <= maxRow;) {\n                const itemsInPath = this._getItemsInVerticalPath(newPos, dims, newPos.row);\n                let nextRow = newPos.row;\n\n                for (let item of itemsInPath) {\n                    if (item.row - nextRow >= dims.y) {\n                        newPos.row = nextRow;\n                        break fixLoop;\n                    }\n\n                    nextRow = item.row + item.sizey;\n                }\n\n                if (maxRow - nextRow >= dims.y) {\n                    newPos.row = nextRow;\n                    break fixLoop;\n                }\n\n                newPos.col = Math.max(newPos.col + 1, Math.min.apply(Math, itemsInPath.map((item) => item.col + dims.x)));\n                newPos.row = 1;\n            }\n        } else if (this._itemFixDirection === 'horizontal') {\n            fixLoop:\n            for (; newPos.row <= maxRow;) {\n                const itemsInPath = this._getItemsInHorizontalPath(newPos, dims, newPos.col);\n                let nextCol = newPos.col;\n\n                for (let item of itemsInPath) {\n                    if (item.col - nextCol >= dims.x) {\n                        newPos.col = nextCol;\n                        break fixLoop;\n                    }\n\n                    nextCol = item.col + item.sizex;\n                }\n\n                if (maxCol - nextCol >= dims.x) {\n                    newPos.col = nextCol;\n                    break fixLoop;\n                }\n\n                newPos.row = Math.max(newPos.row + 1, Math.min.apply(Math, itemsInPath.map((item) => item.row + dims.y)));\n                newPos.col = 1;\n            }\n        }\n\n        return newPos;\n    }\n\n    private _getItemsInHorizontalPath(pos: NgGridItemPosition, dims: NgGridItemSize, startColumn: number = 0): NgGridItem[] {\n        const itemsInPath: NgGridItem[] = [];\n        const topRow: number = pos.row + dims.y - 1;\n\n        this._itemsInGrid.forEach((itemId: string) => {\n            const item = this._items.get(itemId);\n            if (item.col + item.sizex - 1 < startColumn) { return; }    // Item falls after start column\n            if (item.row > topRow) { return; }                          // Item falls above path\n            if (item.row + item.sizey - 1 < pos.row) { return; }        // Item falls below path\n            itemsInPath.push(item);\n        });\n\n        return itemsInPath;\n    }\n\n    private _getItemsInVerticalPath(pos: NgGridItemPosition, dims: NgGridItemSize, startRow: number = 0): NgGridItem[] {\n        const itemsInPath: NgGridItem[] = [];\n        const rightCol: number = pos.col + dims.x - 1;\n\n        this._itemsInGrid.forEach((itemId: string) => {\n            const item = this._items.get(itemId);\n            if (item.row + item.sizey - 1 < startRow) { return; }   // Item falls above start row\n            if (item.col > rightCol) { return; }                    // Item falls after path\n            if (item.col + item.sizex - 1 < pos.col) { return; }    // Item falls before path\n            itemsInPath.push(item);\n        });\n\n        return itemsInPath;\n    }\n\n    private _isWithinBoundsX(pos: NgGridItemPosition, dims: NgGridItemSize, allowExcessiveItems: boolean = false) {\n        return this._maxCols == 0 || (allowExcessiveItems && pos.col == 1) || (pos.col + dims.x - 1) <= this._maxCols;\n    }\n\n    private _fixPosToBoundsX(pos: NgGridItemPosition, dims: NgGridItemSize): NgGridItemPosition {\n        if (!this._isWithinBoundsX(pos, dims)) {\n            pos.col = Math.max(this._maxCols - (dims.x - 1), 1);\n            pos.row ++;\n        }\n        return pos;\n    }\n\n    private _fixSizeToBoundsX(pos: NgGridItemPosition, dims: NgGridItemSize): NgGridItemSize {\n        if (!this._isWithinBoundsX(pos, dims)) {\n            dims.x = Math.max(this._maxCols - (pos.col - 1), 1);\n            dims.y++;\n        }\n        return dims;\n    }\n\n    private _isWithinBoundsY(pos: NgGridItemPosition, dims: NgGridItemSize, allowExcessiveItems: boolean = false) {\n        return this._maxRows == 0 || (allowExcessiveItems && pos.row == 1) || (pos.row + dims.y - 1) <= this._maxRows;\n    }\n\n    private _fixPosToBoundsY(pos: NgGridItemPosition, dims: NgGridItemSize): NgGridItemPosition {\n        if (!this._isWithinBoundsY(pos, dims)) {\n            pos.row = Math.max(this._maxRows - (dims.y - 1), 1);\n            pos.col++;\n        }\n        return pos;\n    }\n\n    private _fixSizeToBoundsY(pos: NgGridItemPosition, dims: NgGridItemSize): NgGridItemSize {\n        if (!this._isWithinBoundsY(pos, dims)) {\n            dims.y = Math.max(this._maxRows - (pos.row - 1), 1);\n            dims.x++;\n        }\n        return dims;\n    }\n\n    private _isWithinBounds(pos: NgGridItemPosition, dims: NgGridItemSize, allowExcessiveItems: boolean = false) {\n        return this._isWithinBoundsX(pos, dims, allowExcessiveItems) && this._isWithinBoundsY(pos, dims, allowExcessiveItems);\n    }\n\n    private _fixPosToBounds(pos: NgGridItemPosition, dims: NgGridItemSize): NgGridItemPosition {\n        return this._fixPosToBoundsX(this._fixPosToBoundsY(pos, dims), dims);\n    }\n\n    private _fixSizeToBounds(pos: NgGridItemPosition, dims: NgGridItemSize): NgGridItemSize {\n        return this._fixSizeToBoundsX(pos, this._fixSizeToBoundsY(pos, dims));\n    }\n\n    private _addToGrid(item: NgGridItem): void {\n        let pos: NgGridItemPosition = item.getGridPosition();\n        const dims: NgGridItemSize = item.getSize();\n\n        if (this._hasGridCollision(pos, dims)) {\n            this._fixGridCollisions(pos, dims);\n            pos = item.getGridPosition();\n        }\n\n        if (this._allowOverlap) {\n            item.zIndex = this._lastZValue++;\n        }\n\n        this._itemsInGrid.add(item.uid);\n    }\n\n    private _removeFromGrid(item: NgGridItem): void {\n        this._itemsInGrid.delete(item.uid);\n    }\n\n    private _updateSize(): void {\n        if (this._destroyed) return;\n        let maxCol: number = this._getMaxCol();\n        let maxRow: number = this._getMaxRow();\n\n        if (maxCol != this._curMaxCol || maxRow != this._curMaxRow) {\n            this._curMaxCol = maxCol;\n            this._curMaxRow = maxRow;\n        }\n\n        this._renderer.setStyle(this._ngEl.nativeElement, 'width', '100%');//(maxCol * (this.colWidth + this.marginLeft + this.marginRight))+'px');\n        if (!this._elementBasedDynamicRowHeight) {\n            this._renderer.setStyle(this._ngEl.nativeElement, 'height', (maxRow * (this.rowHeight + this.marginTop + this.marginBottom)) + 'px');\n        }\n    }\n\n    private _getMaxRow(): number {\n        const itemsRows: number[] = Array.from(this._itemsInGrid, (itemId: string) => {\n            const item = this._items.get(itemId);\n            if (!item) return 0;\n            return item.row + item.sizey - 1;\n        });\n\n        return Math.max.apply(null, itemsRows);\n    }\n\n    private _getMaxCol(): number {\n        const itemsCols: number[] = Array.from(this._itemsInGrid, (itemId: string) => {\n            const item = this._items.get(itemId);\n            if (!item) return 0;\n            return item.col + item.sizex - 1;\n        });\n\n        return Math.max.apply(null, itemsCols);\n    }\n\n    private _getMousePosition(e: any): NgGridRawPosition {\n        if (((<any>window).TouchEvent && e instanceof TouchEvent) || (e.touches || e.changedTouches)) {\n            e = e.touches.length > 0 ? e.touches[0] : e.changedTouches[0];\n        }\n\n        const refPos: any = this._ngEl.nativeElement.getBoundingClientRect();\n\n        let left: number = e.clientX - refPos.left;\n        let top: number = e.clientY - refPos.top;\n\n        if (this.cascade == 'down') top = refPos.top + refPos.height - e.clientY;\n        if (this.cascade == 'right') left = refPos.left + refPos.width - e.clientX;\n\n        if (this.isDragging && this._zoomOnDrag) {\n            left *= 2;\n            top *= 2;\n        }\n\n        return {\n            left: left,\n            top: top\n        };\n    }\n\n    private _getAbsoluteMousePosition(e: any): NgGridRawPosition {\n        if (((<any>window).TouchEvent && e instanceof TouchEvent) || (e.touches || e.changedTouches)) {\n            e = e.touches.length > 0 ? e.touches[0] : e.changedTouches[0];\n        }\n\n        return {\n            left: e.clientX,\n            top: e.clientY\n        };\n    }\n\n    private _getContainerColumns(): number {\n        const maxWidth: number = this._ngEl.nativeElement.getBoundingClientRect().width;\n        const itemWidth: number = this.colWidth + this.marginLeft + this.marginRight;\n        return Math.floor(maxWidth / itemWidth);\n    }\n\n    private _getContainerRows(): number {\n        const maxHeight: number = window.innerHeight - this.marginTop - this.marginBottom;\n        return Math.floor(maxHeight / (this.rowHeight + this.marginTop + this.marginBottom));\n    }\n\n    private _getScreenMargin(): number {\n        const maxWidth: number = this._ngEl.nativeElement.getBoundingClientRect().width;\n        const itemWidth: number = this.colWidth + this.marginLeft + this.marginRight;\n        return Math.floor((maxWidth - (this._maxCols * itemWidth)) / 2);\n    }\n\n    private _getItemFromPosition(position: NgGridRawPosition, e?: any): NgGridItem {\n        return Array.from(this._itemsInGrid, (itemId: string) => this._items.get(itemId)).find((item: NgGridItem) => {\n            if (!item) return false;\n\n            const size: NgGridItemDimensions = item.getDimensions();\n            const pos: NgGridRawPosition = item.getPosition();\n\n            if (e) {\n              if (e.target.closest('.modal-window.grid-item') === item.containerRef.element.nativeElement) {\n                return true;\n              } else {\n                return false;\n              }\n            }\n\n            return position.left >= pos.left && position.left < (pos.left + size.width) &&\n            position.top >= pos.top && position.top < (pos.top + size.height);\n        });\n    }\n\n    private _createPlaceholder(item: NgGridItem): void {\n        const pos: NgGridItemPosition = item.getGridPosition();\n        const dims: NgGridItemSize = item.getSize();\n\n        const factory = this.componentFactoryResolver.resolveComponentFactory(NgGridPlaceholder);\n        var componentRef: ComponentRef<NgGridPlaceholder> = item.containerRef.createComponent(factory);\n        this._placeholderRef = componentRef;\n        const placeholder: NgGridPlaceholder = componentRef.instance;\n        placeholder.registerGrid(this);\n        placeholder.setCascadeMode(this.cascade);\n        placeholder.setGridPosition({ col: pos.col, row: pos.row });\n        placeholder.setSize({ x: dims.x, y: dims.y });\n    }\n\n    private _emitOnItemChange() {\n        const itemOutput: any[] = Array.from(this._itemsInGrid)\n            .map((itemId: string) => this._items.get(itemId))\n            .filter((item: NgGridItem) => !!item)\n            .map((item: NgGridItem) => item.getEventOutput());\n\n        this.onItemChange.emit(itemOutput);\n    }\n\n    private _defineListeners(): void {\n        const element = this._ngEl.nativeElement;\n\n        this._documentMousemove$ = fromEvent<MouseEvent>(document, 'mousemove');\n        this._documentMouseup$ = fromEvent<MouseEvent>(document, 'mouseup');\n        this._mousedown$ = fromEvent(element, 'mousedown');\n        this._mousemove$ = fromEvent(element, 'mousemove');\n        this._mouseup$ = fromEvent(element, 'mouseup');\n        this._touchstart$ = fromEvent(element, 'touchstart');\n        this._touchmove$ = fromEvent(element, 'touchmove');\n        this._touchend$ = fromEvent(element, 'touchend');\n    }\n\n    private _enableListeners(): void {\n        if (this._enabledListener) {\n            return;\n        }\n\n        this._enableMouseListeners();\n\n        if (this._isTouchDevice()) {\n            this._enableTouchListeners();\n        }\n\n        this._enabledListener = true;\n    }\n\n    private _disableListeners(): void {\n        this._subscriptions.forEach((subs: Subscription) => subs.unsubscribe());\n        this._enabledListener = false;\n    }\n\n    private _isTouchDevice(): boolean {\n        return 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n    };\n\n    private _enableTouchListeners(): void {\n        const touchstartSubs = this._touchstart$.subscribe((e: TouchEvent) => this.mouseDownEventHandler(e));\n        const touchmoveSubs = this._touchmove$.subscribe((e: TouchEvent) => this.mouseMoveEventHandler(e));\n        const touchendSubs = this._touchend$.subscribe((e: TouchEvent) => this.mouseUpEventHandler(e));\n\n        this._subscriptions.push(\n            touchstartSubs,\n            touchmoveSubs,\n            touchendSubs\n        );\n    }\n\n    private _enableMouseListeners(): void {\n        const documentMousemoveSubs = this._documentMousemove$.subscribe((e: MouseEvent) => this.mouseMoveEventHandler(e));\n        const documentMouseupSubs = this._documentMouseup$.subscribe((e: MouseEvent) => this.mouseUpEventHandler(e));\n        const mousedownSubs = this._mousedown$.subscribe((e: MouseEvent) => this.mouseDownEventHandler(e));\n        const mousemoveSubs = this._mousemove$.subscribe((e: MouseEvent) => this.mouseMoveEventHandler(e));\n        const mouseupSubs = this._mouseup$.subscribe((e: MouseEvent) => this.mouseUpEventHandler(e));\n\n        this._subscriptions.push(\n            documentMousemoveSubs,\n            documentMouseupSubs,\n            mousedownSubs,\n            mousemoveSubs,\n            mouseupSubs\n        );\n    }\n}\n","import { NgGrid } from './NgGrid';\nimport { NgGridItemConfig, NgGridItemEvent, NgGridItemPosition, NgGridItemSize, NgGridRawPosition, NgGridItemDimensions, ResizeHandle } from '../interfaces/INgGrid';\nimport { Directive, ElementRef, Renderer2, EventEmitter, KeyValueDiffer, KeyValueDiffers, OnInit, OnDestroy, ViewContainerRef, Output, DoCheck } from '@angular/core';\n\n@Directive({\n    selector: '[ngGridItem]',\n    inputs: ['config: ngGridItem']\n})\nexport class NgGridItem implements OnInit, OnDestroy, DoCheck {\n    // Event Emitters\n    @Output() public onItemChange: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>(false);\n    @Output() public onDragStart: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>();\n    @Output() public onDrag: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>();\n    @Output() public onDragStop: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>();\n    @Output() public onDragAny: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>();\n    @Output() public onResizeStart: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>();\n    @Output() public onResize: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>();\n    @Output() public onResizeStop: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>();\n    @Output() public onResizeAny: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>();\n    @Output() public onChangeStart: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>();\n    @Output() public onChange: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>();\n    @Output() public onChangeStop: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>();\n    @Output() public onChangeAny: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>();\n    @Output() public ngGridItemChange: EventEmitter<NgGridItemConfig> = new EventEmitter<NgGridItemConfig>();\n\n    // Default config\n    private static CONST_DEFAULT_CONFIG: NgGridItemConfig = {\n        uid: null,\n        col: 1,\n        row: 1,\n        sizex: 1,\n        sizey: 1,\n        dragHandle: null,\n        resizeHandle: null,\n        fixed: false,\n        draggable: true,\n        resizable: true,\n        borderSize: 25,\n        resizeDirections: null,\n    };\n\n    public isFixed: boolean = false;\n    public isDraggable: boolean = true;\n    public isResizable: boolean = true;\n    public minWidth: number = 0;\n    public minHeight: number = 0;\n    public uid: string = null;\n\n    // Private variables\n    private _payload: any;\n    private _currentPosition: NgGridItemPosition = { col: 1, row: 1 };\n    private _size: NgGridItemSize = { x: 1, y: 1 };\n    private _config = NgGridItem.CONST_DEFAULT_CONFIG;\n    private _userConfig = null;\n    private _dragHandle: string;\n    private _resizeHandle: ResizeHandle;\n    private _borderSize: number;\n    private _elemWidth: number;\n    private _elemHeight: number;\n    private _elemLeft: number;\n    private _elemTop: number;\n    private _added: boolean = false;\n    private _differ: KeyValueDiffer<string, any>;\n    private _cascadeMode: string;\n    private _maxCols: number = 0;\n    private _minCols: number = 0;\n    private _maxRows: number = 0;\n    private _minRows: number = 0;\n    private _resizeDirections: string[] = [];\n    private _zIndex: number = 0;\n\n    set zIndex(zIndex: number) {\n        this._renderer.setStyle(this._ngEl.nativeElement, 'z-index', zIndex.toString());\n        this._zIndex = zIndex;\n    }\n\n    get zIndex(): number {\n        return this._zIndex;\n    }\n\n    // [ng-grid-item] handler\n    set config(v: NgGridItemConfig) {\n        this._userConfig = v;\n\n        const configObject = Object.assign({}, NgGridItem.CONST_DEFAULT_CONFIG, v);\n        for (let x in NgGridItem.CONST_DEFAULT_CONFIG)\n            if (configObject[x] == null)\n                configObject[x] = NgGridItem.CONST_DEFAULT_CONFIG[x];\n\n        this.setConfig(configObject);\n\n        if (this._userConfig != null) {\n            if (this._differ == null) {\n                this._differ = this._differs.find(this._userConfig).create();\n            }\n\n            this._differ.diff(this._userConfig);\n        }\n\n        if (!this._added) {\n            this._added = true;\n            this._ngGrid.addItem(this);\n        }\n\n        this._recalculateDimensions();\n        this._recalculatePosition();\n    }\n\n    get sizex(): number {\n        return this._size.x;\n    }\n\n    get sizey(): number {\n        return this._size.y;\n    }\n\n    get col(): number {\n        return this._currentPosition.col;\n    }\n\n    get row(): number {\n        return this._currentPosition.row;\n    }\n\n    get currentCol(): number {\n        return this._currentPosition.col;\n    }\n\n    get currentRow(): number {\n        return this._currentPosition.row;\n    }\n\n    // Constructor\n    constructor(\n        private _differs: KeyValueDiffers,\n        private _ngEl: ElementRef,\n        private _renderer: Renderer2,\n        private _ngGrid: NgGrid,\n        public containerRef: ViewContainerRef,\n    ) { }\n\n    public onResizeStartEvent(): void {\n        const event: NgGridItemEvent = this.getEventOutput();\n        this.onResizeStart.emit(event);\n        this.onResizeAny.emit(event);\n        this.onChangeStart.emit(event);\n        this.onChangeAny.emit(event);\n    }\n    public onResizeEvent(): void {\n        const event: NgGridItemEvent = this.getEventOutput();\n        this.onResize.emit(event);\n        this.onResizeAny.emit(event);\n        this.onChange.emit(event);\n        this.onChangeAny.emit(event);\n    }\n    public onResizeStopEvent(): void {\n        const event: NgGridItemEvent = this.getEventOutput();\n        this.onResizeStop.emit(event);\n        this.onResizeAny.emit(event);\n        this.onChangeStop.emit(event);\n        this.onChangeAny.emit(event);\n\n        this.onConfigChangeEvent();\n    }\n    public onDragStartEvent(): void {\n        const event: NgGridItemEvent = this.getEventOutput();\n        this.onDragStart.emit(event);\n        this.onDragAny.emit(event);\n        this.onChangeStart.emit(event);\n        this.onChangeAny.emit(event);\n    }\n    public onDragEvent(): void {\n        const event: NgGridItemEvent = this.getEventOutput();\n        this.onDrag.emit(event);\n        this.onDragAny.emit(event);\n        this.onChange.emit(event);\n        this.onChangeAny.emit(event);\n    }\n    public onDragStopEvent(): void {\n        const event: NgGridItemEvent = this.getEventOutput();\n        this.onDragStop.emit(event);\n        this.onDragAny.emit(event);\n        this.onChangeStop.emit(event);\n        this.onChangeAny.emit(event);\n\n        this.onConfigChangeEvent();\n    }\n    public onCascadeEvent(): void {\n        this.onConfigChangeEvent();\n    }\n\n    public ngOnInit(): void {\n        this._renderer.addClass(this._ngEl.nativeElement, 'grid-item');\n        if (this._ngGrid.autoStyle) this._renderer.setStyle(this._ngEl.nativeElement, 'position', 'absolute');\n        this._recalculateDimensions();\n        this._recalculatePosition();\n\n        // Force a config update in case there is no config assigned\n        this.config = this._userConfig;\n    }\n\n    // Public methods\n    public canDrag(e: any): boolean {\n        if (!this.isDraggable) return false;\n\n        if (this._dragHandle) {\n            return this.findHandle(this._dragHandle, e.target);\n        }\n\n        return true;\n    }\n\n    public findHandle(handleSelector: string, startElement: HTMLElement): boolean {\n        try {\n            let targetElem: any = startElement;\n\n            while (targetElem && targetElem != this._ngEl.nativeElement) {\n                if (this.elementMatches(targetElem, handleSelector)) return true;\n\n                targetElem = targetElem.parentElement;\n            }\n        } catch (err) {}\n\n        return false;\n    }\n\n    public canResize(e: any): string {\n        if (!this.isResizable) return null;\n\n        if (this._resizeHandle) {\n            if (typeof this._resizeHandle === 'string') {\n                return this.findHandle(this._resizeHandle, e.target) ? 'bottomright' : null;\n            }\n\n            if (typeof this._resizeHandle !== 'object') return null;\n\n            const resizeDirections = [ 'bottomright', 'bottomleft', 'topright', 'topleft', 'right', 'left', 'bottom', 'top' ];\n            for (let direction of resizeDirections) {\n                if (direction in this._resizeHandle) {\n                    if (this.findHandle(this._resizeHandle[direction], e.target)) {\n                        return direction;\n                    }\n                }\n            }\n\n            return null;\n        }\n\n        if (this._borderSize <= 0) return null;\n\n        const mousePos: NgGridRawPosition = this._getMousePosition(e);\n\n        for (let direction of this._resizeDirections) {\n            if (this.canResizeInDirection(direction, mousePos)) {\n                return direction;\n            }\n        }\n\n        return null;\n    }\n\n    public onMouseMove(e: any): void {\n        if (this._ngGrid.autoStyle) {\n            if (this._ngGrid.resizeEnable) {\n                const resizeDirection = this.canResize(e);\n\n                let cursor: string = 'default';\n                switch (resizeDirection) {\n                    case 'bottomright':\n                    case 'topleft':\n                        cursor = 'nwse-resize';\n                        break;\n                    case 'topright':\n                    case 'bottomleft':\n                        cursor = 'nesw-resize';\n                        break;\n                    case 'top':\n                    case 'bottom':\n                        cursor = 'ns-resize';\n                        break;\n                    case 'left':\n                    case 'right':\n                        cursor = 'ew-resize';\n                        break;\n                    default:\n                        if (this._ngGrid.dragEnable && this.canDrag(e)) {\n                            cursor = 'move';\n                        }\n                        break;\n                }\n\n                this._renderer.setStyle(this._ngEl.nativeElement, 'cursor', cursor);\n            } else if (this._ngGrid.dragEnable && this.canDrag(e)) {\n                this._renderer.setStyle(this._ngEl.nativeElement, 'cursor', 'move');\n            } else {\n                this._renderer.setStyle(this._ngEl.nativeElement, 'cursor', 'default');\n            }\n        }\n    }\n\n    public ngOnDestroy(): void {\n        if (this._added) this._ngGrid.removeItem(this);\n    }\n\n    //    Getters\n    public getElement(): ElementRef {\n        return this._ngEl;\n    }\n\n    public getDragHandle(): string {\n        return this._dragHandle;\n    }\n\n    public getResizeHandle(): ResizeHandle {\n        return this._resizeHandle;\n    }\n\n    public getDimensions(): NgGridItemDimensions {\n        return { 'width': this._elemWidth, 'height': this._elemHeight };\n    }\n\n    public getSize(): NgGridItemSize {\n        return this._size;\n    }\n\n    public getPosition(): NgGridRawPosition {\n        return { 'left': this._elemLeft, 'top': this._elemTop };\n    }\n\n    public getGridPosition(): NgGridItemPosition {\n        return this._currentPosition;\n    }\n\n    //    Setters\n    public setConfig(config: NgGridItemConfig): void {\n        this._config = config;\n\n        this._payload = config.payload;\n        this._currentPosition.col = config.col ? config.col : NgGridItem.CONST_DEFAULT_CONFIG.col;\n        this._currentPosition.row = config.row ? config.row : NgGridItem.CONST_DEFAULT_CONFIG.row;\n        this._size.x = config.sizex ? config.sizex : NgGridItem.CONST_DEFAULT_CONFIG.sizex;\n        this._size.y = config.sizey ? config.sizey : NgGridItem.CONST_DEFAULT_CONFIG.sizey;\n        this._dragHandle = config.dragHandle;\n        this._resizeHandle = config.resizeHandle;\n        this._borderSize = config.borderSize;\n        this.isDraggable = config.draggable ? true : false;\n        this.isResizable = config.resizable ? true : false;\n        this.isFixed = config.fixed ? true : false;\n        this._resizeDirections = config.resizeDirections || this._ngGrid.resizeDirections;\n\n        this._maxCols = !isNaN(config.maxCols) && isFinite(config.maxCols) ? config.maxCols : 0;\n        this._minCols = !isNaN(config.minCols) && isFinite(config.minCols) ? config.minCols : 0;\n        this._maxRows = !isNaN(config.maxRows) && isFinite(config.maxRows) ? config.maxRows : 0;\n        this._minRows = !isNaN(config.minRows) && isFinite(config.minRows) ? config.minRows : 0;\n\n        this.minWidth = !isNaN(config.minWidth) && isFinite(config.minWidth) ? config.minWidth : 0;\n        this.minHeight = !isNaN(config.minHeight) && isFinite(config.minHeight) ? config.minHeight : 0;\n\n        if (this._minCols > 0 && this._maxCols > 0 && this._minCols > this._maxCols) this._minCols = 0;\n        if (this._minRows > 0 && this._maxRows > 0 && this._minRows > this._maxRows) this._minRows = 0;\n\n        if (this._added) {\n            this._ngGrid.updateItem(this);\n        }\n\n        this._size = this.fixResize(this._size);\n\n        this._recalculatePosition();\n        this._recalculateDimensions();\n    }\n\n    public ngDoCheck(): boolean {\n        if (this._differ != null) {\n            const changes: any = this._differ.diff(this._userConfig);\n\n            if (changes != null) {\n                return this._applyChanges(changes);\n            }\n        }\n\n        return false;\n    }\n\n    public setSize(newSize: NgGridItemSize, update: boolean = true): void {\n        newSize = this.fixResize(newSize);\n        this._size = newSize;\n        if (update) this._recalculateDimensions();\n\n        this.onItemChange.emit(this.getEventOutput());\n    }\n\n    public setGridPosition(gridPosition: NgGridItemPosition, update: boolean = true): void {\n        this._currentPosition = gridPosition;\n        if (update) this._recalculatePosition();\n\n        this.onItemChange.emit(this.getEventOutput());\n    }\n\n    public getEventOutput(): NgGridItemEvent {\n        return <NgGridItemEvent>{\n            uid: this.uid,\n            payload: this._payload,\n            col: this._currentPosition.col,\n            row: this._currentPosition.row,\n            sizex: this._size.x,\n            sizey: this._size.y,\n            width: this._elemWidth,\n            height: this._elemHeight,\n            left: this._elemLeft,\n            top: this._elemTop\n        };\n    }\n\n    public setPosition(x: number, y: number): void {\n        switch (this._cascadeMode) {\n            case 'up':\n            case 'left':\n            default:\n                this._renderer.setStyle(this._ngEl.nativeElement, 'left', x + 'px');\n                this._renderer.setStyle(this._ngEl.nativeElement, 'top', y + 'px');\n                break;\n            case 'right':\n                this._renderer.setStyle(this._ngEl.nativeElement, 'right', x + 'px');\n                this._renderer.setStyle(this._ngEl.nativeElement, 'top', y + 'px');\n                break;\n            case 'down':\n                this._renderer.setStyle(this._ngEl.nativeElement, 'left', x + 'px');\n                this._renderer.setStyle(this._ngEl.nativeElement, 'bottom', y + 'px');\n                break;\n        }\n\n        this._elemLeft = x;\n        this._elemTop = y;\n    }\n\n    public setCascadeMode(cascade: string): void {\n        this._cascadeMode = cascade;\n        switch (cascade) {\n            case 'up':\n            case 'left':\n            default:\n                this._renderer.setStyle(this._ngEl.nativeElement, 'left', this._elemLeft + 'px');\n                this._renderer.setStyle(this._ngEl.nativeElement, 'top', this._elemTop + 'px');\n                this._renderer.setStyle(this._ngEl.nativeElement, 'right', null);\n                this._renderer.setStyle(this._ngEl.nativeElement, 'bottom', null);\n                break;\n            case 'right':\n                this._renderer.setStyle(this._ngEl.nativeElement, 'right', this._elemLeft + 'px');\n                this._renderer.setStyle(this._ngEl.nativeElement, 'top', this._elemTop + 'px');\n                this._renderer.setStyle(this._ngEl.nativeElement, 'left', null);\n                this._renderer.setStyle(this._ngEl.nativeElement, 'bottom', null);\n                break;\n            case 'down':\n                this._renderer.setStyle(this._ngEl.nativeElement, 'left', this._elemLeft + 'px');\n                this._renderer.setStyle(this._ngEl.nativeElement, 'bottom', this._elemTop + 'px');\n                this._renderer.setStyle(this._ngEl.nativeElement, 'right', null);\n                this._renderer.setStyle(this._ngEl.nativeElement, 'top', null);\n                break;\n        }\n    }\n\n    public setDimensions(w: number, h: number): void {\n        if (w < this.minWidth) w = this.minWidth;\n        if (h < this.minHeight) h = this.minHeight;\n\n        this._renderer.setStyle(this._ngEl.nativeElement, 'width', w + 'px');\n        this._renderer.setStyle(this._ngEl.nativeElement, 'height', h + 'px');\n\n        this._elemWidth = w;\n        this._elemHeight = h;\n    }\n\n    public startMoving(): void {\n        this._renderer.addClass(this._ngEl.nativeElement, 'moving');\n        const style: any = window.getComputedStyle(this._ngEl.nativeElement);\n        if (this._ngGrid.autoStyle) this._renderer.setStyle(this._ngEl.nativeElement, 'z-index', (parseInt(style.getPropertyValue('z-index')) + 1).toString());\n    }\n\n    public stopMoving(): void {\n        this._renderer.removeClass(this._ngEl.nativeElement, 'moving');\n        const style: any = window.getComputedStyle(this._ngEl.nativeElement);\n        if (this._ngGrid.autoStyle) this._renderer.setStyle(this._ngEl.nativeElement, 'z-index', (parseInt(style.getPropertyValue('z-index')) - 1).toString());\n    }\n\n    public recalculateSelf(): void {\n        this._recalculatePosition();\n        this._recalculateDimensions();\n    }\n\n    public fixResize(newSize: NgGridItemSize): NgGridItemSize {\n        if (this._maxCols > 0 && newSize.x > this._maxCols) newSize.x = this._maxCols;\n        if (this._maxRows > 0 && newSize.y > this._maxRows) newSize.y = this._maxRows;\n\n        if (this._minCols > 0 && newSize.x < this._minCols) newSize.x = this._minCols;\n        if (this._minRows > 0 && newSize.y < this._minRows) newSize.y = this._minRows;\n\n        const itemWidth = (newSize.x * this._ngGrid.colWidth) + ((this._ngGrid.marginLeft + this._ngGrid.marginRight) * (newSize.x - 1));\n        if (itemWidth < this.minWidth) newSize.x = Math.ceil((this.minWidth + this._ngGrid.marginRight + this._ngGrid.marginLeft) / (this._ngGrid.colWidth + this._ngGrid.marginRight + this._ngGrid.marginLeft));\n\n        const itemHeight = (newSize.y * this._ngGrid.rowHeight) + ((this._ngGrid.marginTop + this._ngGrid.marginBottom) * (newSize.y - 1));\n        if (itemHeight < this.minHeight) newSize.y = Math.ceil((this.minHeight + this._ngGrid.marginBottom + this._ngGrid.marginTop) / (this._ngGrid.rowHeight + this._ngGrid.marginBottom + this._ngGrid.marginTop));\n\n        return newSize;\n    }\n\n    // Private methods\n    private elementMatches(element: any, selector: string): boolean {\n        if (!element) return false;\n        if (element.matches) return element.matches(selector);\n        if (element.oMatchesSelector) return element.oMatchesSelector(selector);\n        if (element.msMatchesSelector) return element.msMatchesSelector(selector);\n        if (element.mozMatchesSelector) return element.mozMatchesSelector(selector);\n        if (element.webkitMatchesSelector) return element.webkitMatchesSelector(selector);\n\n        if (!element.document || !element.ownerDocument) return false;\n\n        const matches: any = (element.document || element.ownerDocument).querySelectorAll(selector);\n        let i: number = matches.length;\n        while (--i >= 0 && matches.item(i) !== element) { }\n        return i > -1;\n    }\n\n    private _recalculatePosition(): void {\n        const x: number = (this._ngGrid.colWidth + this._ngGrid.marginLeft + this._ngGrid.marginRight) * (this._currentPosition.col - 1) + this._ngGrid.marginLeft + this._ngGrid.screenMargin;\n        const y: number = (this._ngGrid.rowHeight + this._ngGrid.marginTop + this._ngGrid.marginBottom) * (this._currentPosition.row - 1) + this._ngGrid.marginTop;\n\n        this.setPosition(x, y);\n    }\n\n    private _recalculateDimensions(): void {\n        if (this._size.x < this._ngGrid.minCols) this._size.x = this._ngGrid.minCols;\n        if (this._size.y < this._ngGrid.minRows) this._size.y = this._ngGrid.minRows;\n\n        const newWidth: number = (this._ngGrid.colWidth * this._size.x) + ((this._ngGrid.marginLeft + this._ngGrid.marginRight) * (this._size.x - 1));\n        const newHeight: number = (this._ngGrid.rowHeight * this._size.y) + ((this._ngGrid.marginTop + this._ngGrid.marginBottom) * (this._size.y - 1));\n\n        const w: number = Math.max(this.minWidth, this._ngGrid.minWidth, newWidth);\n        const h: number = Math.max(this.minHeight, this._ngGrid.minHeight, newHeight);\n\n        this.setDimensions(w, h);\n    }\n\n    private _getMousePosition(e: any): NgGridRawPosition {\n        if (e.originalEvent && e.originalEvent.touches) {\n            const oe: any = e.originalEvent;\n            e = oe.touches.length ? oe.touches[0] : (oe.changedTouches.length ? oe.changedTouches[0] : e);\n        } else if (e.touches) {\n            e = e.touches.length ? e.touches[0] : (e.changedTouches.length ? e.changedTouches[0] : e);\n        }\n\n\n        const refPos: NgGridRawPosition = this._ngEl.nativeElement.getBoundingClientRect();\n\n        return {\n            left: e.clientX - refPos.left,\n            top: e.clientY - refPos.top\n        };\n    }\n\n    private _applyChanges(changes: any): boolean {\n        let changed: boolean = false;\n        const changeCheck = (record: any) => {\n            if (this._config[record.key] !== record.currentValue) {\n                this._config[record.key] = record.currentValue;\n                changed = true;\n            }\n        };\n        changes.forEachAddedItem(changeCheck);\n        changes.forEachChangedItem(changeCheck);\n        changes.forEachRemovedItem((record: any) => {\n            changed = true;\n            delete this._config[record.key];\n        });\n\n        if (changed) {\n            this.setConfig(this._config);\n        }\n\n        return changed;\n    }\n\n    private onConfigChangeEvent() {\n        if (this._userConfig === null) return;\n\n        this._config.sizex = this._userConfig.sizex = this._size.x;\n        this._config.sizey = this._userConfig.sizey = this._size.y;\n        this._config.col = this._userConfig.col = this._currentPosition.col;\n        this._config.row = this._userConfig.row = this._currentPosition.row;\n        this.ngGridItemChange.emit(this._userConfig);\n    }\n\n    private canResizeInDirection(direction: string, mousePos: NgGridRawPosition): boolean {\n        switch (direction) {\n            case 'bottomright':\n                return mousePos.left < this._elemWidth && mousePos.left > this._elemWidth - this._borderSize\n                    && mousePos.top < this._elemHeight && mousePos.top > this._elemHeight - this._borderSize; // tslint:disable-line:indent\n            case 'bottomleft':\n                return mousePos.left < this._borderSize && mousePos.top < this._elemHeight\n                    && mousePos.top > this._elemHeight - this._borderSize; // tslint:disable-line:indent\n            case 'topright':\n                return mousePos.left < this._elemWidth && mousePos.left > this._elemWidth - this._borderSize\n                    && mousePos.top < this._borderSize; // tslint:disable-line:indent\n            case 'topleft':\n                return mousePos.left < this._borderSize && mousePos.top < this._borderSize;\n            case 'right':\n                return mousePos.left < this._elemWidth && mousePos.left > this._elemWidth - this._borderSize;\n            case 'left':\n                return mousePos.left < this._borderSize;\n            case 'bottom':\n                return mousePos.top < this._elemHeight && mousePos.top > this._elemHeight - this._borderSize;\n            case 'top':\n                return mousePos.top < this._borderSize;\n            default:\n                return false;\n        }\n    }\n}\n","import { NgModule } from '@angular/core';\nimport { NgGrid } from '../directives/NgGrid';\nimport { NgGridItem } from '../directives/NgGridItem';\nimport { NgGridPlaceholder } from '../components/NgGridPlaceholder';\n\n@NgModule({\n  declarations:     [ NgGrid, NgGridItem, NgGridPlaceholder ],\n  entryComponents:  [ NgGridPlaceholder ],\n  exports:          [ NgGrid, NgGridItem ]\n})\nexport class NgGridModule {}\n"]}